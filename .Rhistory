intRsqexpbetaRx<-sum(values(RsqexpbetaRx))/(ncol(S)*nrow(S))
# Calculate the variance of R(X_beta).  This is Eqn 4 in the manuscript
variance<-intRsqexpbetaRx/intexpbetaRx - (intRexpbetaRx/intexpbetaRx)^2
variance
# Calculate N_{alpha,p}(beta).  This is Equation (3) in the Main Text
Nalphapbetas = ((zalpha+zp)^2/variance)*(beta^(-2))
#This is the sample size of locations required
list(Nalphapbetas=Nalphapbetas, variance=variance,
zalpha=zalpha,zp=zp)
}
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)  #coefs
X = cbind(1,values(covs[[1]]))  # design matrix
lambda = exp(X%*%beta) #intensity of selection
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}
# Get from function
zalpha=N.temp$zalpha
zp=N.temp$zp
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
Eq8
paste("M should be greater than or equal to ", round(Eq8,digits=0))
paste("M (tracked individuals) should be greater than or equal to ", round(Eq8,digits=0))
#Number of individuals
M = 30
# Population-level coefs
beta_mu = 0.2
beta_s = 0.5 # note the amount of variation
beta_s2 = beta_s^2
# Individual level coefs
set.seed(4254)
# Assume the same number of locations per individual
N = rep(1000,M)
# Assume the same number of locations per individual
N = rep(1000,M)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)  #coefs
X = cbind(1,values(covs[[1]]))  # design matrix
lambda = exp(X%*%beta) #intensity of selection
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)  #coefs
X = cbind(1,values(covs[[1]]))  # design matrix
lambda = exp(X%*%beta) #intensity of selection
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}
# Equation 5 of Street et al. 2021
sigma <- 1/sqrt(N*N.variance)
# Get from function
zalpha=N.temp$zalpha
zp=N.temp$zp
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
paste("M (tracked individuals) should be greater than or equal to ", round(Eq8,digits=0))
Eq8
N.temp$zalpha
N.variance
#Number of individuals
M = 30
# Population-level coefs
beta_mu = 0.2
beta_s = 0.5 # note the amount of variation
beta_s2 = beta_s^2
# Individual level coefs
set.seed(4254)
beta.ind <- rnorm(M, beta_mu,beta_s)
# Assume the same number of locations per individual
N = rep(1000,M)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)  #coefs
X = cbind(1,values(covs[[1]]))  # design matrix
lambda = exp(X%*%beta) #intensity of selection
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}
N.variance
# Equation 5 of Street et al. 2021
sigma <- 1/sqrt(N*N.variance)
# Get from function
zalpha = N.temp$zalpha
zp = N.temp$zp
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
paste("M (tracked individuals) should be greater than or equal to ", round(Eq8,digits=0))
z=1
M = 30
beta_mu = seq(0.1,2,length.out=10)
beta_s = 0.5
beta_s2 = beta_s^2
min.indiv = rep(NA, length(beta_mu))
# Individual level coefs
set.seed(4254)
beta.ind <- rnorm(M, beta_mu[z],beta_s)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)
X = cbind(1,values(covs[[1]]))
lambda = exp(X%*%beta)
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}
N = rep(1000,M)
sigma <- 1/sqrt(N*N.variance)
zalpha = N.temp$zalpha
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
min.indiv[z] = Eq8
min.indiv[z]
min.indiv[z] = Eq8
Eq8
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu[z]^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
Eq8
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu[z]^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu[z]^2)
Eq8
M = 30
beta_mu = seq(0.1,2,length.out=10)
beta_s = 0.5
beta_s2 = beta_s^2
min.indiv = rep(NA, length(beta_mu))
for(z in 1:length(beta_mu)){
# Individual level coefs
set.seed(4254)
beta.ind <- rnorm(M, beta_mu[z],beta_s)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)
X = cbind(1,values(covs[[1]]))
lambda = exp(X%*%beta)
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}  #end i loop
N = rep(1000,M)
sigma <- 1/sqrt(N*N.variance)
zalpha = N.temp$zalpha
zp = N.temp$zp
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu[z]^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu[z]^2)
min.indiv[z] = Eq8
}#end z loop
plot(beta_mu,min.indiv)
M = 30
beta_mu = seq(0.1,0.75,length.out=10)
beta_s = 0.5
beta_s2 = beta_s^2
min.indiv = rep(NA, length(beta_mu))
for(z in 1:length(beta_mu)){
# Individual level coefs
set.seed(4254)
beta.ind <- rnorm(M, beta_mu[z],beta_s)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)
X = cbind(1,values(covs[[1]]))
lambda = exp(X%*%beta)
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}  #end i loop
N = rep(1000,M)
sigma <- 1/sqrt(N*N.variance)
zalpha = N.temp$zalpha
zp = N.temp$zp
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu[z]^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu[z]^2)
min.indiv[z] = Eq8
}#end z loop
plot(beta_mu,min.indiv)
plot(beta_mu,min.indiv)
plot(beta_mu,min.indiv,ylab="Minimum Number of Individuals Tracked",lwd=3,col=4,type="b")
plot(beta_mu,min.indiv,ylab="Minimum Number of Individuals Tracked",lwd=3,col=4,type="b")
M = 30
beta_mu = 0.2
beta_s = seq(0.01,0.5,length.out=10)
beta_s2 = beta_s^2
min.indiv = rep(NA, length(beta_mu))
for(z in 1:length(beta_s)){
# Individual level coefs
set.seed(4254)
beta.ind <- rnorm(M, beta_mu,beta_s)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)
X = cbind(1,values(covs[[1]]))
lambda = exp(X%*%beta)
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}  #end i loop
N = rep(1000,M)
sigma <- 1/sqrt(N*N.variance)
zalpha = N.temp$zalpha
zp = N.temp$zp
Eq8 = (beta_s2*(zalpha+zp)^2 + sqrt((beta_s^4)*(zalpha+zp)^4 +
4*(beta_mu[z]^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu[z]^2)
min.indiv[z] = Eq8
}#end z loop
beta_s
sigma
Eq8 = (beta_s2[z]*(zalpha+zp)^2 + sqrt((beta_s[z]^4)*(zalpha+zp)^4 +
4*(beta_mu^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
Eq8
M = 30
beta_mu = 0.2
beta_s = seq(0.01,0.5,length.out=10)
beta_s2 = beta_s^2
min.indiv = rep(NA, length(beta_mu))
for(z in 1:length(beta_s)){
# Individual level coefs
set.seed(4254)
beta.ind <- rnorm(M, beta_mu,beta_s)
N.variance = NULL
for(i in 1:M){
beta = matrix(c(-1,beta.ind[i]),nrow=2,ncol=1)
X = cbind(1,values(covs[[1]]))
lambda = exp(X%*%beta)
HSF.True=covs[[1]]
values(HSF.True)= lambda
N.temp = sample.size.used.locs(alpha = 0.05,
p_val = 0.05,
HSF.True = HSF.True,
S = covs[[1]],
beta = beta[2]
)
N.variance = c(N.variance, N.temp$variance)
}  #end i loop
N = rep(1000,M)
sigma <- 1/sqrt(N*N.variance)
zalpha = N.temp$zalpha
zp = N.temp$zp
Eq8 = (beta_s2[z]*(zalpha+zp)^2 + sqrt((beta_s[z]^4)*(zalpha+zp)^4 +
4*(beta_mu^2)*(zalpha+zp)^2*sum(sigma))) / (2*beta_mu^2)
min.indiv[z] = Eq8
}#end z loop
beta_s
plot(beta_s,min.indiv,ylab="Minimum Number of Individuals Tracked",lwd=3,col=4,type="b")
plot(beta_s2,min.indiv,ylab="Minimum Number of Individuals Tracked",lwd=3,col=4,type="b")
#Load packages
library(geoR)
library(circular)
library(glmmTMB)
library(raster)
library(sp)
library(survival)
library(Rfast)
library(remotes)
library(plotrix)
library(ggplot2)
library(knitr)
# Install github repository
#    remotes::install_github("Pakillo/grateful")
library(grateful)
# Source simulation function
source("sim.ind.movement.hsf.r")
# Source bootstrapping function
source("mean_ci_boot.r")
# Load spatial covariates stored in a save R object
load("Covs")
# Number of Sampled individuals (e.g., tracked via GPS telemetry)
n.indiv = 30
# Define the true population-level coefficients
# and use these to simulate individual-level coefficients
# Selection against at population-level
# Low variation among individuals
beta1.mu = -1
beta1.sd = 0.2
set.seed(543543)
beta1=rnorm(n.indiv,
mean = beta1.mu,
sd = beta1.sd
)
# No selection at population-level
# Wide variation among individuals
beta2.mu = 0
beta2.sd = 1
set.seed(5435431)
beta2=rnorm(n.indiv,
mean = beta2.mu,
sd = beta2.sd
)
# Selection for this feature at population-level
# Low variation among individuals
beta3.mu = 1
beta3.sd = 0.2
set.seed(1543543)
beta3=rnorm(n.indiv,
mean = beta3.mu,
sd = beta3.sd
)
# Combine coefficients and plot these values
betas=data.frame(b1 = beta1,
b2 = beta2,
b3 = beta3)
# Combine into 1 raster stack
covs = stack(covs[[1]],
covs[[2]],
covs[[3]]
)
# Change the extent to be larger to accommodate more realistic movements
#  (not required but makes me feel better)
extent(covs) = c(0,4000,0,4000)
# Names of variables
names(covs[[1]]) = 'dist.dev'
names(covs[[2]]) = 'forest'
names(covs[[3]]) = 'shrub'
par(mfrow=c(2,3))
plot(covs[[1]], main='dist.dev')
plot(covs[[2]], main='forest')
plot(covs[[3]], main='shrub')
hist(values(covs[[1]]), main='dist.dev')
hist(values(covs[[2]]), main='forest')
hist(values(covs[[3]]), main='shrub')
hsf.true = vector("list",n.indiv)
for (i in 1:n.indiv){
hsf.true[[i]] = (covs[[1]]*betas[i,1]+
covs[[2]]*betas[i,2]+
covs[[3]]*betas[i,3]
)
}
# Set number of available samples per used
n.avail = 100
# Number of movements
n.time = 400
# Number of possible steps to choose from at each iteration- these are not available locations, this is for the simulation of the movement path
n.step = 400
# Population (across individual) turning angle parameters for von mises distribution
angle.mean = 0
angle.kappa = 0.0001
# Step length rate of exponential distribution
step.rate = 0.01
# Simulate individual-level movement-based habitat selection data
sims =  sim.ind.movement.hsf(hsf.true = hsf.true,
n.time = n.time,
n.step = n.step,
n.avail = n.avail,
angle.mean = angle.mean,
angle.kappa = angle.kappa,
step.rate = step.rate
)
#Plot the true HSF with locations for individual k
k=10
par(mfrow=c(1,1))
plot(hsf.true[[k]])
points(sims$locs[[k]]$use.x,
sims$locs[[k]]$use.y,
pch=16
)
# Combine data into a single data.frame
sims2 = do.call("rbind", sims$indiv)
head(sims2)
dim(sims2)
# Create ID vector for individual's data
LETTERS702 <- c(LETTERS, sapply(LETTERS, function(x) paste0(x, LETTERS)))
ID = rep(LETTERS702[1:n.indiv],each=nrow(sims$indiv[[1]]))
sims2$ID=ID
# Create new strata
sims2$indiv.id.strata = paste0(sims2$ID,
sims2$strata
)
# The number of unique identifiers needed
# n.step*n.indiv
length(unique(sims2$indiv.id.strata)) == n.step*n.indiv
dim(sims2)
head(sims2)
# Pooled model - no consideration of individual variability
model.pool = glmmTMB(status ~ dist.dev + forest + shrub +
(1|indiv.id.strata),
data=sims2,
family=poisson,
doFit = FALSE
)
model.pool$parameters$theta[1] = log(1e3)
model.pool$mapArg = list(theta=factor(c(NA)))
options(warn=-1)
model.pool = glmmTMB:::fitTMB(model.pool)
options(warn=0)
# Look at estimates when pooling the data
summary(model.pool)
# Separate models to each individual
indiv.fit = lapply(sims[[1]],FUN=function(x){
temp=glmmTMB(status ~ dist.dev+forest+shrub + (1|strata),
data=x,
family=poisson,
doFit = FALSE
)
temp$parameters$theta[1] = log(1e3)
temp$mapArg = list(theta=factor(c(NA)))
options(warn=-1)
temp = glmmTMB:::fitTMB(temp)
options(warn=0)
temp
})
# Extract pooled estimates with Confidence intervals
pool.effect = broom.mixed::tidy(model.pool, effects = "fixed", conf.int = TRUE)
# Extract separate individual estimates
indiv.coef = lapply(indiv.fit,FUN=function(x){
temp=broom.mixed::tidy(x, effects = "fixed",
conf.int = TRUE
)
data.frame(temp[-1,c(4,8,9)])
})
# These are all coefs (1:3) for each individual 1:n.indiv
estimates = sapply(indiv.coef,"[[",1)
LCI = sapply(indiv.coef,"[[",2)
UCI = sapply(indiv.coef,"[[",3)
layout(matrix(c(1,2), nrow = 1, ncol = 2, byrow = TRUE),
width=c(2,1))
plotCI(1:n.indiv,
y=estimates[1,],
ui=UCI[1,],
li=LCI[1,],
ylab="beta",
xlab="Individual",
lwd=2,
ylim=c(-2.5,4)
)
legend("topright",lwd=3,col=c(1,2,3),
legend=c("dist.dev","forest","shrub"),box.lty=0,y.intersp=0.8)
plotCI(1:n.indiv,y=estimates[2,],
ui=UCI[2,],
li=LCI[2,],
ylab="beta_1",
xlab="Individual",
lwd=2,
col=2,
add=TRUE
)
plotCI(1:n.indiv,y=estimates[3,],
ui=UCI[3,],
li=LCI[3,],
ylab="beta_1",
xlab="Individual",
lwd=2,
col=3,
add=TRUE
)
plotCI(c(1,1,1),y=pool.effect$estimate[2:4],
xlim=c(0.95,1.05),
ui=pool.effect$conf.high[2:4],
li=pool.effect$conf.low[2:4],
ylab="beta",
xlab="Population",
lwd=2,
ylim=c(-2.5,4),
col=c(1,2,3),
xaxt='n'
)
unlink("MovementHSF_cache", recursive = TRUE)
unlink("MovementHSF_cache", recursive = TRUE)
